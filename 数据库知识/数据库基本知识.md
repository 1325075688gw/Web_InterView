### 非关系型数据库和关系型数据库区别，优势比较？

#### 非关系型数据库的优势：

\1. 性能

NOSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以性能非常高。

\2. 可扩展性

同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。

#### 关系型数据库的优势：

\1. 复杂查询

可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。

\2. 事务支持

使得对于安全性能很高的数据访问要求得以实现。

#### 总结

对于这两类数据库，对方的优势就是自己的弱势，反之亦然。

NOSQL数据库慢慢开始具备SQL数据库的一些复杂查询功能，比如MongoDB。

对于事务的支持也可以用一些系统级的原子操作来实现例如乐观锁之类的方法来曲线救国，比如Redis set nx。



### 数据库的读写分离、主从复制，主从复制分析的 7 个问题？

#### 主从复制的几种方式

**同步复制**

- 所谓的同步复制，意思是master的变化，必须等待slave-1,slave-2,...,slave-n完成后才能返回。 这样，显然不可取，也不是MySQL复制的默认设置。比如，在WEB前端页面上，用户增加了条记录，需要等待很长时间。

**异步复制**

- 如同AJAX请求一样。master只需要完成自己的数据库操作即可。至于slaves是否收到二进制日志，是否完成操作，不用关心,MySQL的默认设置。

**半同步复制**

- master只保证slaves中的一个操作成功，就返回，其他slave不管。 这个功能，是由google为MySQL引入的。

#### 主从复制分析的 7 个问题

**问题1：master的写操作，slaves被动的进行一样的操作，保持数据一致性，那么slave是否可以主动的进行写操作？**

假设slave可以主动的进行写操作，slave又无法通知master，这样就导致了master和slave数据不一致了。因此slave不应该进行写操作，至少是slave上涉及到复制的数据库不可以写。实际上，这里已经揭示了读写分离的概念。

**问题2：主从复制中，可以有N个slave,可是这些slave又不能进行写操作，要他们干嘛？**

以实现数据备份。

类似于高可用的功能，一旦master挂了，可以让slave顶上去，同时slave提升为master。

异地容灾，比如master在北京，地震挂了，那么在上海的slave还可以继续。

主要用于实现scale out,分担负载,可以将读的任务分散到slaves上。

【很可能的情况是，一个系统的读操作远远多于写操作，因此写操作发向master，读操作发向slaves进行操作】

**问题3：主从复制中有master,slave1,slave2,...等等这么多MySQL数据库，那比如一个JAVA WEB应用到底应该连接哪个数据库?**

当 然，我们在应用程序中可以这样，`insert/delete/update`这些更新数据库的操作，用`connection(for master)`进行操作，`select用connection(for slaves)`进行操作。那我们的应用程序还要完成怎么从slaves选择一个来执行select，例如使用简单的轮循算法。

这样的话，相当于应用程序完成了SQL语句的路由，而且与MySQL的主从复制架构非常关联，一旦master挂了，某些slave挂了，那么应用程序就要修改了。能不能让应用程序与MySQL的主从复制架构没有什么太多关系呢？

找一个组件，application program只需要与它打交道，用它来完成MySQL的代理，实现SQL语句的路由。

MySQL proxy并不负责，怎么从众多的slaves挑一个？可以交给另一个组件(比如haproxy)来完成。

这就是所谓的`MySQL READ WRITE SPLITE，MySQL`的读写分离。

**问题4：如果MySQL proxy , direct , master他们中的某些挂了怎么办？**

总统一般都会弄个副总统，以防不测。同样的，可以给这些关键的节点来个备份。

**问题5：当master的二进制日志每产生一个事件，都需要发往slave，如果我们有N个slave,那是发N次，还是只发一次？**

如果只发一次，发给了slave-1，那slave-2,slave-3,...它们怎么办？

显 然，应该发N次。实际上，在MySQL master内部，维护N个线程，每一个线程负责将二进制日志文件发往对应的slave。master既要负责写操作，还的维护N个线程，负担会很重。可以这样，slave-1是master的从，slave-1又是slave-2,slave-3,...的主，同时slave-1不再负责select。 slave-1将master的复制线程的负担，转移到自己的身上。这就是所谓的多级复制的概念。

**问题6：当一个select发往MySQL proxy，可能这次由slave-2响应，下次由slave-3响应，这样的话，就无法利用查询缓存了。**

应该找一个共享式的缓存，比如memcache来解决。将slave-2,slave-3,...这些查询的结果都缓存至mamcache中。

**问题7：随着应用的日益增长，读操作很多，我们可以扩展slave，但是如果master满足不了写操作了，怎么办呢？**

scale on ?更好的服务器？ 没有最好的，只有更好的，太贵了。。。

scale out ? 主从复制架构已经满足不了。

可以分库【垂直拆分】，分表【水平拆分】。



### MySQL都有什么锁，死锁判定原理和具体场景，死锁怎么解决？

#### MySQL都有什么锁

MySQL有三种锁的级别：页级、表级、行级。

- 表级锁：开销小，加锁快；==不会出现死锁；==锁定粒度大，发生锁冲突的概率最高,并发度最低。
- 行级锁：开销大，加锁慢；==会出现死锁；==锁定粒度最小，发生锁冲突的概率最低,并发度也最高。
- 页面锁：开销和加锁时间界于表锁和行锁之间；==会出现死锁；==锁定粒度界于表锁和行锁之间，并发度一般

#### 什么情况下会造成死锁

- 所谓死锁<DeadLock>: 是指两个或两个以上的进程在执行过程中。
- 因争夺资源而造成的一种互相等待的现象,若无外力作用,它们都将无法推进下去。
- 此时称系统处于死锁状态或系统产生了死锁,这些永远在互相等竺的进程称为死锁进程。
- ==表级锁不会产生死锁.==,MyISAM表级锁，所以解决死锁主要还是针对于最常用的InnoDB。

死锁的关键在于：两个(或以上)的Session加锁的顺序不一致。

那么对应的解决死锁问题的关键就是：让不同的session加锁有次序。

#### 死锁的解决办法

- **查出的线程杀死 kill**

```
SELECT trx_MySQL_thread_id FROM information_schema.INNODB_TRX;
```

- **设置锁的超时时间**

Innodb 行锁的等待时间，单位秒。可在会话级别设置，RDS 实例该参数的默认值为 50（秒）。

生产环境不推荐使用过大的 `innodb_lock_wait_timeout`参数值

该参数支持在会话级别修改，方便应用在会话级别单独设置某些特殊操作的行锁等待超时时间，如下：

```
set innodb_lock_wait_timeout=1000; —设置当前会话 Innodb 行锁等待超时时间，单位秒。
```



### MySQL慢查询怎么解决？

- slow_query_log 慢查询开启状态。
- slow_query_log_file 慢查询日志存放的位置（这个目录需要MySQL的运行帐号的可写权限，一般设置为MySQL的数据存放目录）。
- long_query_time 查询超过多少秒才记录。





### varchar和char的使用场景？

##### char的长度是不可变的，而varchar的长度是可变的。

定义一个char[10]和varchar[10]。

==如果存进去的是‘csdn’,那么char所占的长度依然为10，除了字符‘csdn’外，后面跟六个空格，varchar就立马把长度变为4了，取数据的时候，char类型的要用trim()去掉多余的空格，而varchar是不需要的。==

char的存取数度还是要比varchar要快得多，因为其长度固定，方便程序的存储与查找。

char也为此付出的是空间的代价，因为其长度固定，所以难免会有多余的空格占位符占据空间，可谓是以空间换取时间效率。

varchar是以空间效率为首位。

==char的存储方式是：对英文字符（ASCII）占用1个字节，对一个汉字占用两个字节。==

==varchar的存储方式是：对每个英文字符占用2个字节，汉字也占用2个字节。==

==两者的存储数据都非unicode的字符数据。==



### MySQL 高并发环境解决方案？

MySQL 高并发环境解决方案 分库 分表 分布式 增加二级缓存。。。。。

需求分析：互联网单位 每天大量数据读取，写入，并发性高。

- 现有解决方式：水平分库分表，==由单点分布到多点数据库中，从而降低单点数据库压力==。**（这儿是这个原因：一个人的信息如果有10个字段，假设我们常用的也就3个字段，我们就可以分表，然后，我们查询的时候，slave1可以查询个人信息的姓名，slave2查询个人信息的年龄（假设年龄和姓名被分表了））**
- 集群方案：解决DB宕机带来的单点DB不能访问问题。==（解决异地容灾问题和负载均衡问题）==
- 集群方案：解决DB宕机带来的单点DB不能访问问题。
- 读写分离策略：极大限度提高了应用中==Read数据的速度和并发量==。==无法解决高写入压力。==



#### 072 MySQL几种备份方式（重点）

##### 1、逻辑备份：使用mysql自带的mysqldump工具进行备份。备份成sql文件形式。

　　　　优点：最大好处是能够与正在运行的mysql自动协同工作，在运行期间可以确保备份是当时的点，它会自动将对应操作的表锁定，不允许其他用户修改(只能访问)。可能会阻止修改操作。sql文件通用方便移植。 
　　　　缺点：备份的速度比较慢。如果是数据量很多的时候。就很耗时间。如果数据库服务器处在提供给用户服务状态，在这段长时间操作过程中，意味着要锁定表(一般是读锁定，只能读不能写入数据)。那么服务就会影响的。 

##### 　　2、物理备份：直接拷贝mysql的数据目录。

　　直接拷贝只适用于myisam类型的表。这种类型的表是与机器独立的。但实际情况是，你设计数据库的时候不可能全部使用myisam类型表。你也不可能因为myisam类型表与机器独立，方便移植，于是就选择这种表，这并不是选择它的理由。 
　　　　缺点：你不能去操作正在运行的mysql服务器(在拷贝的过程中有用户通过应用程序访问更新数据，这样就无法备份当时的数据)可能无法移植到其他机器上去。 

##### 3、双机热备份。(主从复制)

　　mysql数据库没有增量备份的机制。当数据量太大的时候备份是一个很大的问题。还好mysql数据库提供了一种主从备份的机制(也就是双机热备) 
　　　　优点：适合数据量大的时候。现在明白了。大的互联网公司对于mysql数据备份，都是采用热机备份。搭建多台数据库服务器，进行主从复制。



#### 083 FULLTEXT全文索引

　　即为全文索引，目前只有MyISAM引擎支持。其可以在CREATE TABLE ，ALTER TABLE ，CREATE INDEX 使用，不过目前只有 CHAR、VARCHAR ，TEXT 列上可以创建全文索引。值得一提的是，在数据量较大时候，现将数据放入一个没有全局索引的表中，然后再用CREATE INDEX创建FULLTEXT索引，要比先为一张表建立FULLTEXT然后再将数据写入的速度快很多。FULLTEXT索引也是按照分词原理建立索引的。西文中，大部分为字母文字，分词可以很方便的按照空格进行分割。中文不能按照这种方式进行分词。Mysql的中文分词插件Mysqlcft，有了它，就可以对中文进行分词。



#### 074 数据库不能停机，请问如何备份? 如何进行全备份和增量备份?

　　可以使用逻辑备份和双机热备份。 
　　完全备份：完整备份一般一段时间进行一次，且在网站访问量最小的时候，这样常借助批处理文件定时备份。主要是写一个批处理文件在里面写上处理程序的绝对路径然后把要处理的东西写在后面，即完全备份数据库。 
　　增量备份：对ddl和dml语句进行二进制备份。且5.0无法增量备份，5.1后可以。如果要实现增量备份需要在my.ini文件中配置备份路径即可，重启mysql服务器，增量备份就启动了。


####  **065 使用短索引**

　　对串列进行索引，如果可能应该指定一个前缀长度。例如，如果有一个CHAR(255)的列，如果在前10个或20个字符内，多数值是惟一的，那么就不要对整个列进行索引。短索引不仅可以提高查询速度而且可以节省磁盘空间和I/O操作。