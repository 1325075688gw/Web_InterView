### 非关系型数据库和关系型数据库区别，优势比较？

#### 非关系型数据库的优势：

\1. 性能

NOSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以性能非常高。

\2. 可扩展性

同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。

#### 关系型数据库的优势：

\1. 复杂查询

可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。

\2. 事务支持

使得对于安全性能很高的数据访问要求得以实现。

#### 总结

对于这两类数据库，对方的优势就是自己的弱势，反之亦然。

NOSQL数据库慢慢开始具备SQL数据库的一些复杂查询功能，比如MongoDB。

对于事务的支持也可以用一些系统级的原子操作来实现例如乐观锁之类的方法来曲线救国，比如Redis set nx。



### 数据库的读写分离、主从复制，主从复制分析的 7 个问题？

#### 主从复制的几种方式

**同步复制**

- 所谓的同步复制，意思是master的变化，必须等待slave-1,slave-2,...,slave-n完成后才能返回。 这样，显然不可取，也不是MySQL复制的默认设置。比如，在WEB前端页面上，用户增加了条记录，需要等待很长时间。

**异步复制**

- 如同AJAX请求一样。master只需要完成自己的数据库操作即可。至于slaves是否收到二进制日志，是否完成操作，不用关心,MySQL的默认设置。

**半同步复制**

- master只保证slaves中的一个操作成功，就返回，其他slave不管。 这个功能，是由google为MySQL引入的。

#### 主从复制分析的 7 个问题

**问题1：master的写操作，slaves被动的进行一样的操作，保持数据一致性，那么slave是否可以主动的进行写操作？**

假设slave可以主动的进行写操作，slave又无法通知master，这样就导致了master和slave数据不一致了。因此slave不应该进行写操作，至少是slave上涉及到复制的数据库不可以写。实际上，这里已经揭示了读写分离的概念。

**问题2：主从复制中，可以有N个slave,可是这些slave又不能进行写操作，要他们干嘛？**

以实现数据备份。

类似于高可用的功能，一旦master挂了，可以让slave顶上去，同时slave提升为master。

异地容灾，比如master在北京，地震挂了，那么在上海的slave还可以继续。

主要用于实现scale out,分担负载,可以将读的任务分散到slaves上。

【很可能的情况是，一个系统的读操作远远多于写操作，因此写操作发向master，读操作发向slaves进行操作】

**问题3：主从复制中有master,slave1,slave2,...等等这么多MySQL数据库，那比如一个JAVA WEB应用到底应该连接哪个数据库?**

当 然，我们在应用程序中可以这样，`insert/delete/update`这些更新数据库的操作，用`connection(for master)`进行操作，`select用connection(for slaves)`进行操作。那我们的应用程序还要完成怎么从slaves选择一个来执行select，例如使用简单的轮循算法。

这样的话，相当于应用程序完成了SQL语句的路由，而且与MySQL的主从复制架构非常关联，一旦master挂了，某些slave挂了，那么应用程序就要修改了。能不能让应用程序与MySQL的主从复制架构没有什么太多关系呢？

找一个组件，application program只需要与它打交道，用它来完成MySQL的代理，实现SQL语句的路由。

MySQL proxy并不负责，怎么从众多的slaves挑一个？可以交给另一个组件(比如haproxy)来完成。

这就是所谓的`MySQL READ WRITE SPLITE，MySQL`的读写分离。

**问题4：如果MySQL proxy , direct , master他们中的某些挂了怎么办？**

总统一般都会弄个副总统，以防不测。同样的，可以给这些关键的节点来个备份。

**问题5：当master的二进制日志每产生一个事件，都需要发往slave，如果我们有N个slave,那是发N次，还是只发一次？**

如果只发一次，发给了slave-1，那slave-2,slave-3,...它们怎么办？

显 然，应该发N次。实际上，在MySQL master内部，维护N个线程，每一个线程负责将二进制日志文件发往对应的slave。master既要负责写操作，还的维护N个线程，负担会很重。可以这样，slave-1是master的从，slave-1又是slave-2,slave-3,...的主，同时slave-1不再负责select。 slave-1将master的复制线程的负担，转移到自己的身上。这就是所谓的多级复制的概念。

**问题6：当一个select发往MySQL proxy，可能这次由slave-2响应，下次由slave-3响应，这样的话，就无法利用查询缓存了。**

应该找一个共享式的缓存，比如memcache来解决。将slave-2,slave-3,...这些查询的结果都缓存至mamcache中。

**问题7：随着应用的日益增长，读操作很多，我们可以扩展slave，但是如果master满足不了写操作了，怎么办呢？**

scale on ?更好的服务器？ 没有最好的，只有更好的，太贵了。。。

scale out ? 主从复制架构已经满足不了。

可以分库【垂直拆分】，分表【水平拆分】。



### MySQL都有什么锁，死锁判定原理和具体场景，死锁怎么解决？

#### MySQL都有什么锁

MySQL有三种锁的级别：页级、表级、行级。

- 表级锁：开销小，加锁快；==不会出现死锁；==锁定粒度大，发生锁冲突的概率最高,并发度最低。
- 行级锁：开销大，加锁慢；==会出现死锁；==锁定粒度最小，发生锁冲突的概率最低,并发度也最高。
- 页面锁：开销和加锁时间界于表锁和行锁之间；==会出现死锁；==锁定粒度界于表锁和行锁之间，并发度一般

#### 什么情况下会造成死锁

- 所谓死锁<DeadLock>: 是指两个或两个以上的进程在执行过程中。
- 因争夺资源而造成的一种互相等待的现象,若无外力作用,它们都将无法推进下去。
- 此时称系统处于死锁状态或系统产生了死锁,这些永远在互相等竺的进程称为死锁进程。
- ==表级锁不会产生死锁.==,MyISAM表级锁，所以解决死锁主要还是针对于最常用的InnoDB。

死锁的关键在于：两个(或以上)的Session加锁的顺序不一致。

那么对应的解决死锁问题的关键就是：让不同的session加锁有次序。

#### 死锁的解决办法

- **查出的线程杀死 kill**

```
SELECT trx_MySQL_thread_id FROM information_schema.INNODB_TRX;
```

- **设置锁的超时时间**

Innodb 行锁的等待时间，单位秒。可在会话级别设置，RDS 实例该参数的默认值为 50（秒）。

生产环境不推荐使用过大的 `innodb_lock_wait_timeout`参数值

该参数支持在会话级别修改，方便应用在会话级别单独设置某些特殊操作的行锁等待超时时间，如下：

```
set innodb_lock_wait_timeout=1000; —设置当前会话 Innodb 行锁等待超时时间，单位秒。
```



### MySQL慢查询怎么解决？

- slow_query_log 慢查询开启状态。
- slow_query_log_file 慢查询日志存放的位置（这个目录需要MySQL的运行帐号的可写权限，一般设置为MySQL的数据存放目录）。
- long_query_time 查询超过多少秒才记录。





### varchar和char的使用场景？

##### char的长度是不可变的，而varchar的长度是可变的。

定义一个char[10]和varchar[10]。

==如果存进去的是‘csdn’,那么char所占的长度依然为10，除了字符‘csdn’外，后面跟六个空格，varchar就立马把长度变为4了，取数据的时候，char类型的要用trim()去掉多余的空格，而varchar是不需要的。==

char的存取数度还是要比varchar要快得多，因为其长度固定，方便程序的存储与查找。

char也为此付出的是空间的代价，因为其长度固定，所以难免会有多余的空格占位符占据空间，可谓是以空间换取时间效率。

varchar是以空间效率为首位。

==char的存储方式是：对英文字符（ASCII）占用1个字节，对一个汉字占用两个字节。==

==varchar的存储方式是：对每个英文字符占用2个字节，汉字也占用2个字节。==

==两者的存储数据都非unicode的字符数据。==



### MySQL 高并发环境解决方案？

MySQL 高并发环境解决方案 分库 分表 分布式 增加二级缓存。。。。。

需求分析：互联网单位 每天大量数据读取，写入，并发性高。

- 现有解决方式：水平分库分表，==由单点分布到多点数据库中，从而降低单点数据库压力==。**（这儿是这个原因：一个人的信息如果有10个字段，假设我们常用的也就3个字段，我们就可以分表，然后，我们查询的时候，slave1可以查询个人信息的姓名，slave2查询个人信息的年龄（假设年龄和姓名被分表了））**
- 集群方案：解决DB宕机带来的单点DB不能访问问题。==（解决异地容灾问题和负载均衡问题）==
- 集群方案：解决DB宕机带来的单点DB不能访问问题。
- 读写分离策略：极大限度提高了应用中==Read数据的速度和并发量==。==无法解决高写入压力。==