### 数据库的事务和隔离级别

#### 1.数据库的事务

**事务的四大特征：**（事务只能有两种状态，事务执行失败：回滚，事务执行成功，提交事务）
	**1. 原子性**：事务是不可分割的最小操作单位，要么同时成功，要么同时失败。
	**2. 持久性：**当事务提交或回滚后，数据库会持久化的保存数据。（不管你关闭软件还是关机，数据都已经持久化改变了）
	**3. 隔离性：**多个事务之间。相互独立。（真实情况下，事务会相互影响）
	**4. 一致性：**事务操作前后，数据总量不变。（比如小红给小明转50元钱，不管事务提交还是回滚，两人的总金额不变）





#### 2.事务的隔离级别

**概念：**

​	多个事务之间相互隔离，相互独立，你不影响我，我不影响你（就是每个事物只动自己范围内的数据，不去动其它事务的数据）。但是如果多个事务操作同一批数据，这时候就会引发一些问题，设置不同的隔离级别就可以解决这些问题。



**存在问题：**
		**1. 脏读：**一个事务，读取**（select）**到另一个事务中没有提交的数据；

​		**例如：**小明给小白还1000块钱，MySQL操作之后，小白去看，果然有1000块钱，但是小明在小黑查看完数据后，赶紧事务回滚，过一会小白去银行取钱，结果取不出来，一查寻，发现里面没有钱，这就是脏读，也就是小白读取到了另一个事务未提交的数据。

​		**2. 不可重复读(虚读)：**在同一个事务中，两次读取到的数据不一样。**====>**事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新**（update）**并提交，导致事务A多次读取同一数据时，数据不一致；

​		**3. 可重复读但会产生幻读**：一个事务操作(DML)数据表中所有记录时，另一个事务添加**（insert）**了一条数据，则第一个事务再次查询数据时，发现多出了一些数据，就像眼花了一样，产生幻读现象：

​		**例如：**事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作 这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。 而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有跟没有修改一样，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。



 **隔离级别：**

​	**1. read uncommitted：未提交读**（一个事物未提交的数据，允许另一个事务也能读到）
		产生的问题：脏读、不可重复读、幻读
	**2. read committed：提交读（只有提交的数据才能读到）** （```Oracle默认，SQL-Sever默认```）
		产生的问题：不可重复读、幻读，解决了脏读（没有commit的数据读出来还是原始值）

​	**这儿我重点讲下为什么提交读还会产生不可重复读问题**

​	在提交读(READ COMMITTED)级别中，基于锁机制并发控制的DBMS需要对选定对象的写锁(write locks)一直保持到事务结束，但是读锁(read locks)在SELECT操作完成后马上释放（因此“不可重复读”现象可能会发生，见下面描述），也就是我们一个1事务读取数据后，加锁，另一个事务，任然可以读取该数据，但是读取到的是1事务没有commit的数据，也就是读出来还是原始值。事务1事务未提交前不能读取事务1中的数据。

​	我们首先设置我们的数据库事务级别为提交读，开启事务1，对student表做更新，但是不对其提交，再开启事务2对数据进行读取。

```python
start TRANSACTION;
select * from student;
update student set name = 'a1' where id = 1;
select * from student;
在该事务中，更新数据后，我们查看student表，其中的数据已经发生了变化。我们开启事务2对数据查询。
select * from student;
在该事务中查询到的student还是旧数据，对事务1进行提交，再在事务2中查询，数据则获取到的为我们最新的数据。
再次期间事务2和事务1中读取数据，事务1未提交时两个读取的数据不一致，可能发生不可重复读。
```



​	**3.repeatable read：可重复读 （MySQL默认）**

​		产生的问题：幻读
	**4. serializable：串行化**
		当一个事务对数据进行操作时，另一个事务不能对同样的数据进行操作，必须等另一个事务回滚或者提交后才能操作，好比多线程中的锁，
		如果一个事物对数据进行操作时，另一个事务对数据进行操作，这时候第二个操作会夯住，也就是阻塞
		可以解决所有的问题



**脏读和不可重复读的区别：**脏读是读到了未提交的数据(有其他用户在更改数据)，而不可重复读读的是已经提交的，但是违反了事务的一致性要求. 这是因为该数据在查询期间，被另一个事务修改并提交了

不可重复读和幻读的区别：幻读和不可重复读都是读取了另一个事务中已经提交的数据，不同的是，不可重复读查询的都是同一个数据项，而幻读是针对一个数据整体（如数据的条数）



https://www.cnblogs.com/xiaohanlin/p/8644749.html

https://blog.csdn.net/luzhensmart/article/details/84069469

[事务的隔离级别](https://blog.csdn.net/qzcsu/article/details/84451372)

**很多人容易搞混不可重复读和幻读，确实这两者有些相似。**但不可重复读重点在于update和delete，而幻读的重点在于insert。

CREATE TABLE `student1` (
  `id` int(11) NOT NULL,
  `name` varchar(50) NOT NULL,
  `age` int(11) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
INSERT INTO `student1` VALUES ('1', '小明', '88');
INSERT INTO `student1` VALUES ('2', '小红', '13');
INSERT INTO `student1` VALUES ('3', '小李', '14');


如果使用锁机制来实现这两种隔离级别，在可重复读中，该sql第一次读取到数据后，就将这些数据加锁，其它事务无法修改这些数据，就可以实现可重复 读了。但这种方法却无法锁住insert的数据，所**以当事务A先前读取了数据，或者修改了全部数据，事务B还是可以insert数据提交，**这时事务A就会 发现莫名其妙多了一条之前没有的数据，这就是幻读，不能通过行锁来避免。需要Serializable隔离级别 ，**读用读锁，写用写锁，读锁和写锁互斥**，这么做可以有效的避免幻读、不可重复读、脏读等问题，但会极大的降低数据库的并发能力。

所以说不可重复读和幻读最大的区别，就在于如何通过锁机制来解决他们产生的问题。

上文说的，是使用悲观锁机制来处理这两种问题，但是MySQL、ORACLE、PostgreSQL等成熟的数据库，出于性能考虑，都是使用了以乐观锁为理论基础的MVCC（多版本并发控制）来避免这两种问题。





### 有哪些锁（乐观锁悲观锁），select 时怎么加排它锁？

#### 悲观锁（Pessimistic Lock）

==悲观锁的特点是先获取锁，再进行业务操作，==即“悲观”的认为获取锁是非常有可能失败的，因此要先确保获取锁成功再进行业务操作。==通常所说的“一锁二查三更新”即指的是使用悲观锁。通常来讲在数据库上的悲观锁需要数据库本身提供支持，即通过常用的select … for update操作来实现悲观锁。==当数据库执行select for update时会获取被select中的数据行的行锁，因此其他并发执行的select for update如果试图选中同一行则会发生排斥（需要等待行锁被释放），因此达到锁的效果。select for update获取的行锁会在当前事务结束时自动释放，因此必须在事务中使用。

这里需要注意的一点是不同的数据库对select for update的实现和支持都是有所区别的，例如oracle支持select for update no wait，表示如果拿不到锁立刻报错，而不是等待，MySQL就没有no wait这个选项。==另外MySQL还有个问题是select for update语句执行中所有扫描过的行都会被锁上，这一点很容易造成问题。因此如果在MySQL中用悲观锁务必要确定走了索引，而不是全表扫描。==

#### 乐观锁（Optimistic Lock）

乐观锁，也叫乐观并发控制，它假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理各自影响的那部分数据。在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。==如果其他事务有更新的话，那么当前正在提交的事务会进行回滚。==

乐观锁的特点先进行业务操作，不到万不得已不去拿锁==。即“乐观”的认为拿锁多半是会成功的，因此在进行完业务操作需要实际更新数据的最后一步再去拿一下锁就好==。

==乐观锁在数据库上的实现完全是逻辑的，不需要数据库提供特殊的支持。====一般的做法是在需要锁的数据上增加一个版本号，或者时间戳，然后按照如下方式实现：==

乐观锁（给表加一个版本号字段） 这个并不是乐观锁的定义，给表加版本号，是数据库实现乐观锁的一种方式。

```
1. SELECT data AS old_data, version AS old_version FROM …;

2. 根据获取的数据进行业务操作，得到new_data和new_version

3. UPDATE SET data = new_data, version = new_version(这儿一般是old_version+1) WHERE version = old_version
if (updated row > 0) {
    // 乐观锁获取成功，操作完成
} else {
    // 乐观锁获取失败，回滚并重试
}
```

==乐观锁在不发生取锁（数据资源）失败的情况下开销比悲观锁小，但是一旦发生失败回滚开销则比较大，因此适合用在取锁（数据资源）失败概率比较小的场景，可以提升系统并发性能==

乐观锁还适用于一些比较特殊的场景，例如在业务操作过程中无法和数据库保持连接等悲观锁无法适用的地方。

#### 总结

悲观锁和乐观锁是数据库用来保证数据并发安全防止更新丢失的两种方法，例子在`select ... for update`前加个事务就可以防止更新丢失。悲观锁和乐观锁大部分场景下差异不大，一些独特场景下有一些差别，一般我们可以从如下几个方面来判断。

- ==响应速度：==如果需要非常高的响应速度，建议采用乐观锁方案，成功就执行，==不成功就失败，不需要等待其他并发去释放锁。==
- ==冲突频率：==如果冲突频率非常高，建议采用悲观锁，保证成功率，如果冲突频率大，乐观锁会需要多次重试才能成功，代价比较大。
- ==重试代价：==如果重试代价大，建议采用悲观锁。





#### ● 请你说一说数据库的三大范式

##### 参考回答：

​	第一范式：当关系模式R的所有属性都不能再分解为更基本的数据单位时，称R是满足第一范式，即属性不可分

​	第一范式的合理遵循需要根据系统的实际需求来定。比如某些数据库系统中需要用到“地址”这个属性，本来直接将“地址”属性设计成一个数据库表的字段就行。但是如果系统经常会访问“地址”属性中的“城市”部分，那么就非要将“地址”这个属性重新拆分为省份、城市、详细地址等多个部分进行存储，这样在对地址中某一部分操作的时候将非常方便。这样设计才算满足了数据库的第一范式，如下表所示。



​	第二范式：如果关系模式R满足第一范式，并且R得所有非主属性都完全依赖于R的每一个候选关键属性，称R满足第二范式

​	比如要设计一个订单信息表，因为订单中可能会有多种商品，所以要将订单编号和商品编号作为数据库表的联合主键。



第三范式：设R是一个满足第一范式条件的关系模式，X是R的任意属性集，如果X非传递依赖于R的任意一个候选关键字，称R满足第三范式，即非主属性不传递依赖于键码