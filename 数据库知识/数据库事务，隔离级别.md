### 数据库的事务和隔离级别

#### 1.数据库的事务

**事务的四大特征：**（事务只能有两种状态，事务执行失败：回滚，事务执行成功，提交事务）
	**1. 原子性**：事务是不可分割的最小操作单位，要么同时成功，要么同时失败。
	**2. 持久性：**当事务提交或回滚后，数据库会持久化的保存数据。（不管你关闭软件还是关机，数据都已经持久化改变了）
	**3. 隔离性：**多个事务之间。相互独立。（真实情况下，事务会相互影响）
	**4. 一致性：**事务操作前后，数据总量不变。（比如小红给小明转50元钱，不管事务提交还是回滚，两人的总金额不变）





#### 2.事务的隔离级别

**概念：**

​	多个事务之间相互隔离，相互独立，你不影响我，我不影响你（就是每个事物只动自己范围内的数据，不去动其它事务的数据）。但是如果多个事务操作同一批数据，这时候就会引发一些问题，设置不同的隔离级别就可以解决这些问题。



**存在问题：**
		**1. 脏读：**一个事务，读取**（select）**到另一个事务中没有提交的数据；

​		**例如：**小明给小白还1000块钱，MySQL操作之后，小白去看，果然有1000块钱，但是小明在小黑查看完数据后，赶紧事务回滚，过一会小白去银行取钱，结果取不出来，一查寻，发现里面没有钱，这就是脏读，也就是小白读取到了另一个事务未提交的数据。

​		**2. 不可重复读(虚读)：**在同一个事务中，两次读取到的数据不一样。**====>**事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新**（update）**并提交，导致事务A多次读取同一数据时，数据不一致；

​		**3. 可重复读但会产生幻读**：一个事务操作(DML)数据表中所有记录时，另一个事务添加**（insert）**了一条数据，则第一个事务再次查询数据时，发现多出了一些数据，就像眼花了一样，产生幻读现象：

​		**例如：**事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作 这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。 而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有跟没有修改一样，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。



 **隔离级别：**

​	**1. read uncommitted：未提交读**（一个事物未提交的数据，允许另一个事务也能读到）
		产生的问题：脏读、不可重复读、幻读
	**2. read committed：提交读（只有提交的数据才能读到）** （```Oracle默认，SQL-Sever默认```）
		产生的问题：不可重复读、幻读，解决了脏读（没有commit的数据读出来还是原始值）

​	**这儿我重点讲下为什么提交读还会产生不可重复读问题**

​	在提交读(READ COMMITTED)级别中，基于锁机制并发控制的DBMS需要对选定对象的写锁(write locks)一直保持到事务结束，但是读锁(read locks)在SELECT操作完成后马上释放（因此“不可重复读”现象可能会发生，见下面描述），也就是我们一个1事务读取数据后，加锁，另一个事务，任然可以读取该数据，但是读取到的是1事务没有commit的数据，也就是读出来还是原始值。事务1事务未提交前不能读取事务1中的数据。

​	我们首先设置我们的数据库事务级别为提交读，开启事务1，对student表做更新，但是不对其提交，再开启事务2对数据进行读取。

```python
start TRANSACTION;
select * from student;
update student set name = 'a1' where id = 1;
select * from student;
在该事务中，更新数据后，我们查看student表，其中的数据已经发生了变化。我们开启事务2对数据查询。
select * from student;
在该事务中查询到的student还是旧数据，对事务1进行提交，再在事务2中查询，数据则获取到的为我们最新的数据。
再次期间事务2和事务1中读取数据，事务1未提交时两个读取的数据不一致，可能发生不可重复读。
```



​	**3.repeatable read：可重复读 （MySQL默认）**

​		产生的问题：幻读
	**4. serializable：串行化**
		当一个事务对数据进行操作时，另一个事务不能对同样的数据进行操作，必须等另一个事务回滚或者提交后才能操作，好比多线程中的锁，
		如果一个事物对数据进行操作时，另一个事务对数据进行操作，这时候第二个操作会夯住，也就是阻塞
		可以解决所有的问题



**脏读和不可重复读的区别：**脏读是读到了未提交的数据(有其他用户在更改数据)，而不可重复读读的是已经提交的，但是违反了事务的一致性要求. 这是因为该数据在查询期间，被另一个事务修改并提交了

不可重复读和幻读的区别：幻读和不可重复读都是读取了另一个事务中已经提交的数据，不同的是，不可重复读查询的都是同一个数据项，而幻读是针对一个数据整体（如数据的条数）



https://www.cnblogs.com/xiaohanlin/p/8644749.html

https://blog.csdn.net/luzhensmart/article/details/84069469

[事务的隔离级别](https://blog.csdn.net/qzcsu/article/details/84451372)

**很多人容易搞混不可重复读和幻读，确实这两者有些相似。**但不可重复读重点在于update和delete，而幻读的重点在于insert。

CREATE TABLE `student1` (
  `id` int(11) NOT NULL,
  `name` varchar(50) NOT NULL,
  `age` int(11) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
INSERT INTO `student1` VALUES ('1', '小明', '88');
INSERT INTO `student1` VALUES ('2', '小红', '13');
INSERT INTO `student1` VALUES ('3', '小李', '14');


如果使用锁机制来实现这两种隔离级别，在可重复读中，该sql第一次读取到数据后，就将这些数据加锁，其它事务无法修改这些数据，就可以实现可重复 读了。但这种方法却无法锁住insert的数据，所**以当事务A先前读取了数据，或者修改了全部数据，事务B还是可以insert数据提交，**这时事务A就会 发现莫名其妙多了一条之前没有的数据，这就是幻读，不能通过行锁来避免。需要Serializable隔离级别 ，**读用读锁，写用写锁，读锁和写锁互斥**，这么做可以有效的避免幻读、不可重复读、脏读等问题，但会极大的降低数据库的并发能力。

所以说不可重复读和幻读最大的区别，就在于如何通过锁机制来解决他们产生的问题。

上文说的，是使用悲观锁机制来处理这两种问题，但是MySQL、ORACLE、PostgreSQL等成熟的数据库，出于性能考虑，都是使用了以乐观锁为理论基础的MVCC（多版本并发控制）来避免这两种问题。





#### 3.悲观锁和乐观锁

##### 悲观锁

​	正如其名，它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处 于锁定状态。悲观锁的实现，**往往依靠数据库提供的锁机制**（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机 制，也无法保证外部系统不会修改数据）。

​	在悲观锁的情况下，为了保证事务的隔离性，就需要一致性锁定读。读取数据时给加锁，其它事务无法修改这些数据。修改删除数据时也要加锁，其它事务无法读取这些数据。

##### 乐观锁

​	相对悲观锁而言，乐观锁机制采取了更加宽松的加锁机制。悲观锁大多数情况下依靠数据库的锁机制实现，以保证操作最大程度的独占性。但随之而来的就是数据库性能的大量开销，特别是对长事务而言，这样的开销往往无法承受。

​	而乐观锁机制在一定程度上解决了这个问题。乐观锁，**大多是基于数据版本（ Version ）记录机制实现**。何谓数据版本？即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个 “version” 字段来实现。读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如 果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。



#### ● 请你说一说数据库的三大范式

##### 参考回答：

第一范式：当关系模式R的所有属性都不能再分解为更基本的数据单位时，称R是满足第一范式，即属性不可分

第二范式：如果关系模式R满足第一范式，并且R得所有非主属性都完全依赖于R的每一个候选关键属性，称R满足第二范式

第三范式：设R是一个满足第一范式条件的关系模式，X是R的任意属性集，如果X非传递依赖于R的任意一个候选关键字，称R满足第三范式，即非主属性不传递依赖于键码