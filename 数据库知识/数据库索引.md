#### 1.请你说一下什么是索引？

​	索引是对数据表中的一列或者多列数据进行排序的一种结构，它就像新华字典前面的目录一样，可以加速我们的查询，MySQL用的是B+树索引，相比于hash索引，有很多优点，比如我们可以范围查询。而且对于内存不大，无法一次加载hash索引表的情况下，B+树索引任然有用，它可以分批加载，所以仍能起到加速查找的作用。

- **索引的优点**
  1. 正取使用索引可以避免全表扫描，加速查询
  2. 创建系统唯一性索引，可以保证每一行数据的唯一性；
  3. 大大提高数据检索的速度；
  4. 加快表与表之间的链接，特别是具有主、外键关系的表；
  5. 在针对使用order by和groupby子句进行数据检索时，可以显著地减少分组和排序的时间；
- **索引的缺点**
  1. 创建和维护索引是需要耗费时间的，这种时间会随着数据量的增加而增加；
  2. 索引需要占用物理空间，除了数据表占用数据空间外，每一个索引还要占用一定的物理空间，如果要建立聚集索引，那么需要的空间就会更大；
  3. 当表中的数据进行增加、删除和修改的时候，索引也要动态地维护，这样就降低了**数据的维护速度**；

#### 2.创建索引的建议

- 我们没必要给每个列都创建索引，创建太多的索引反而会降低性能，浪费存储空间。因此在创建索引的时候，应该仔细考虑在哪些列上可以创建索引，在哪些列上不能了创建索引。下面列出一些经验总结的建议：
- **应该创建索引的列：**
  - 在经常需要搜索的列，也就是Select后跟的列，加快检索速度；
  - 在经常使用Where子句中的列创建索引，加快条件的判断速度；
  - 在主键的列上；（主键）
  - 在经常使用连接外键的列上；（外键）
  - 在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的；
  - 对串列进行索引，如果可能应该指定一个前缀长度。例如，如果有一个CHAR(255)的列，如果在前10个或20个字符内，多数值是惟一的，那么就不要对整个列进行索引==。短索引不仅可以提高查询速度而且可以节省磁盘空间和I/O操作。==
- **不应该创建索引的列：**
  - 查询中很少使用得列不应该创建索引。创建的话有些得不偿失；
  - 对于一个数据列中有大量重复值的，我们也不应该创建索引。比如性别：就'男'，'女','保密',我们就不需要创建索引，因为数据不唯一，比如我们检索男生，那么使用索引还是会扫描很多内容，并不能明显加快检索速度，而且建立索引还会浪费存储空间；
  - 对于text、image、varchar(max)和bit数据类型的列不应该增加索引，这是因为，这些列值的数据量要么量相当大，要么取值很少；
  - 当修改性能远远大于检索性能的时候，不应该创建索引。从上面索引的缺点知道，修改性能和检索性能是互相矛盾的。当增加索引时，就会提高检索性能，但会降低修改性能。当减少索引时，就会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引；也就是我们如果经常修改该数据，那么我们不应该创建索引

#### 3.索引的类型

​    存储引擎负责实现索引，因此不是所有的存储索引都支持聚集索引。

​    根据索引的顺序与数据表的物理顺序是否相同，可以把索引分成两种类型：

- 一种是数据表的物理顺序与索引顺序相同的聚集索引，
- 另一种是数据表的物理顺序与索引顺序不同的非聚集索引。

- **使用聚集索引和非聚集索引的建议：**
  - 每个表只能有一个聚集索引，因为表中数据的物理顺序是唯一的
  - 在创建任何非聚集索引之前先创建聚集索引，这是因为聚集索引改变了表中行的物理顺序，数据行按照一定的顺序排列，并且自动维护这个顺序。
  - 聚集索引的平均大小大约是数据表的5%，但是，实际的聚集索引的大小 常常根据索引列的大小而变化，因此一定要保证有足够的空间来创建聚集索引




#### 4.MySQL中常见索引有：

- 普通索引：普通索引仅有一个功能：加速查询

- 唯一索引：唯一索引有两个功能：加速查询 和 唯一约束（可含null）

- 组合索引：

  - 组合索引是将n个列组合成一个索引

  - 其应用场景为：频繁的同时使用n列来进行查询，如：where n1 = 'alex' and n2 = 666。

  - 如上创建组合索引之后（遵循最左前缀），查询：

    - name and email  -- 使用索引
    - name                 -- 使用索引
    - email                 -- 不使用索引

    注意：对于同时搜索n个条件时，组合索引的性能好于多个单一索引合并。

- 主键索引：主键有两个功能：加速查询 和 唯一约束（不可含null）




#### 5.MySQL B+Tree索引和Hash索引的区别？

- Hash索引结构的特殊性，其检索效率非常高，索引的检索可以一次定位;
- B+树索引需要从根节点到枝节点，最后才能访问到页节点这样多次的IO访问;






#### 6.什么时候不能命中索引

在MySQL中，并不是你建立了索引，并且你在SQL中使用到了该列，MySQL就肯定会使用到那些索引的，有一些情况很可能在你不知不觉中，你就“成功的避开了”MySQL的所有索引。

现假设有t_stu表，age,sname上建立了索引

- 索引列参与计算:

  ```mysql
  如果where条件中age列中使用了计算，则不会使用该索引

  SELECT `sname` FROM `t_stu` WHERE `age`=20;-- 会使用索引
  SELECT `sname` FROM `t_stu` WHERE `age`+10=30;-- 不会使用索引！！因为所有索引列参与了计算
  SELECT `sname` FROM `t_stu` WHERE `age`=30-10;-- 会使用索引
  故，如果需要计算，千万不要计算到索引列，想方设法让其计算到表达式的另一边去。
  ```


  

- 索引列使用了函数:

  ```
  同样的道理，索引列使用了函数，一样会导致相同的后果
  SELECT `sname` FROM `stu` WHERE concat(`sname`,'abc') ='Jaskeyabc'; -- 不会使用索引,因为使用了函数运算,原理与上面相同
  SELECT `sname` FROM `stu` WHERE `sname` =concat('Jaskey','abc'); -- 会使用索引
  ```



- 索引列使用like,(不一定会使用索引):

  ```mysql
  SELECT * FROM `houdunwang` WHERE `uname` LIKE '前缀就走索引%' -- 走索引
  SELECT * FROM `houdunwang` WHERE `uname` LIKE '后缀不走索引%' -- 不走索引
  所以当需要搜索email列中.com结尾的字符串而email上希望走索引时候,可以考虑数据库存储一个反向的内容reverse_email
  SELECT * FROM table WHERE reverse_email LIKE REVERSE('%.com'); -- 走索引
  注：以上如果你使用REVERSE(email) = REVERSE('%.com')，一样得不到你想要的结果，因为你在索引列email列上使用了函数，MySQL不会使用该列索引
  ```




- 索引列上使用正则表达式也不会走索引:
- 类型不同不走索引:




  ```
  这是一个坑，假设有一张表,里面的a列是一个字符char类型,且a上建立了索引,你用它与数字类型做比较判断的话：
   CREATE TABLE `t1` (`a` char(10));
   SELECT * FROM `t1` WHERE `a`='1' -- 走索引
   SELECT * FROM `t2` WHERE `a`=1 -- 字符串和数字比较，不走索引！
  但是如果那个表那个列是一个数字类型，拿来和字符类型的做比较，则不会影响到使用索引
   CREATE TABLE `t2` (`b` int);

   SELECT * FROM `t2` WHERE `b`='1' -- 虽然b是数字类型，和'1'比较依然走索引
  但是，无论如何，这种额外的隐式类型转换都是开销，而且由于有字符和数字比就不走索引的情况，故建议避免一切隐式类型转换
  ```



- 尽量避免OR操作:

  ```mysql
  select * from dept where dname='jaskey' or loc='bj' or deptno=45 --如果条件中有or,即使其中有条件带索引也不会使用。换言之,就是要求使用的所有字段,都必须建立索引
  所以除非每个列都建立了索引，否则不建议使用OR，在多列OR中，可以考虑用UNION 替换
    select * from dept where dname='jaskey' union
    select * from dept where loc='bj' union
    select * from dept where deptno=45
  ```


