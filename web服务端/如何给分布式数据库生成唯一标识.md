#### [分布式系统唯一ID生成方案汇总](https://www.cnblogs.com/haoxinyue/p/5208136.html)

#### 1.uuid

​	这就是uuid,32位字符,中间4个杠,所以一共36个

```python
UUID中有固定的四个 ”-“，所以32位长。
128位是 二进制， 每四个二进制转一个16进制数。 128/4=32
所以，就是32个16进制数的字符了。

88b622ed-dcc8-6bda-3985-e5c6bc0d71b4
c95161f8-3af0-8faf-3dc6-44499adc03db
c774c36c-95c5-bae6-b454-5608dfade9a7
20b0a783-2e43-f7a1-6b5d-6ef71cb22941
0d6b3e43-eec7-c1fb-e5c1-4bae7cade237
abfe3169-7b8c-e3eb-dd52-e1a411d795ba
9c084b60-7b4f-ec1d-21fc-b75c4ca917d8
797755ec-0446-e615-9980-5f838ded3d83
```



- **通过一定算法,由机器生成**

  ​	为了保证UUID的唯一性，规范定义了包括网卡MAC地址、时间戳、名字空间（Namespace）、随机或伪随机数、时序等元素，以及从这些元素生成UUID的算法。UUID的复杂特性在保证了其唯一性的同时，意味着只能由**计算机生成**。

- **非人工指定，非人工识别**

  ​	UUID是不能人工指定的，除非你冒着UUID重复的风险。UUID的复杂性决定了“一般人“不能直接从一个UUID知道哪个对象和它关联。

- **在特定的范围内重复的可能性极小**

  ​	通过算法生成的uuid几乎不会重复,也用不完,每秒产生几兆的uuid,可以连续产生几十亿年.

  ​

- **优点：**

  1）简单，代码方便。调用库函数就可以直接生成

  2）生成ID性能非常好，基本不会有性能问题。

  3）全球唯一，在遇见数据迁移，系统数据合并，或者数据库变更等情况下，可以从容应对。尤其是分布式系统中也能从容应对

   

- **缺点：**

  1）虽然uuid生成中，含有时间信息，但是由于其算法极其复杂，所以我们无法根据生成的uuid,进行人工识别，无法判断谁先生成，所以无法排序，无法保证趋势递增。

  2）UUID往往是使用字符串存储，查询的效率比较低。

  3）uuid存储空间比较大,每一个uuid要占用128位,也就是16Byte，如果是海量数据库，就需要考虑存储量的问题。

  4）传输数据量大

  5）uuid不可人工识别，不可读。

  ​

#### 3.数据库自增长序列或字段

​	最常见的方式。利用数据库，全数据库唯一。

**优点：**

1）简单，代码方便，性能可以接受。

2）数字ID天然排序，对分页或者需要排序的结果很有帮助。

 

**缺点：**

1）不同数据库语法和实现不同，数据库迁移的时候或多数据库版本支持的时候需要处理。

2）在单个数据库或读写分离或一主多从的情况下，只有一个主库可以生成。**有单点故障的风险。**

3）在性能达不到要求的情况下，比较难于扩展。

4）**如果遇见多个系统需要合并或者涉及到数据迁移会相当痛苦。**

5）分表分库的时候会有麻烦。

**优化方案：**

1）针对主库单点，如果有多个Master库，则每个Master库设置的起始数字不一样，步长一样，可以是Master的个数。比如：Master1 生成的是 1，4，7，10，Master2生成的是2,5,8,11 Master3生成的是 3,6,9,12。这样就可以有效生成集群中的唯一ID，也可以大大降低ID生成数据库操作的负载。



#### 2.Redis生成ID

​	当使用数据库来生成ID性能不够要求的时候，我们可以尝试使用Redis来生成ID。这主要依赖于Redis是单线程的，同一时刻只能生成一个ID，所以也可以用生成全局唯一的ID。可以用Redis的原子操作 INCR和INCRBY来实现。

​	可以使用**Redis集群来获取更高的吞吐量**。假如一个集群中有5台Redis。可以初始化每台Redis的值分别是1,2,3,4,5，然后步长都是5（为集群数量）。各个Redis生成的ID为：

```http
A：1,6,11,16,21
B：2,7,12,17,22
C：3,8,13,18,23
D：4,9,14,19,24
E：5,10,15,20,25
```

​	这个，随便负载到哪个机确定好，未来很难做修改。但是3-5台服务器基本能够满足器上，都可以获得不同的ID。但是步长和初始值一定需要事先需要了。**使用Redis集群也可以方式单点故障的问题。**

​	另外，比较适合使用**Redis来生成每天从0开始的流水号。比如订单号=日期+当日自增长号。**可以每天在Redis中生成一个Key，使用INCR进行累加。

 

**优点：**

1）不依赖于数据库，灵活方便，且性能优于数据库。可以使用edis集群来解决Redis单线程问题。同时避免Redis单点故障问题

2）数字ID天然排序，**对分页或者需要排序的结果很有帮助。**

**缺点：**

1）如果系统中没有Redis，还需要引入新的组件，增加系统复杂度。

2）需要编码和配置的工作量比较大

 

